---
title: EtherCAT in Aether
description: What EtherCAT is, how it works, and why Aether adopts an EtherCAT‑style model for deterministic motion control.
icon: Network
---

## What Is EtherCAT? [#what-is-ethercat]

The [EtherCAT](https'://en.wikipedia.org/wiki/EtherCAT') protocol is utilized in the Aether project due to its nature as a real-time [fieldbus](https'://en.wikipedia.org/wiki/Fieldbus') that operates over standard Ethernet. In this system, a single master transmits a frame that passes through every slave device in the network. Each device reads and writes its data to this frame at the set transmission speed as it passes "on the fly." Once the frame has visited every device, it returns to the master, carrying all the updated process data for that cycle.

This protocol is built on a flexible master/slave topology, which allows for various wiring configurations such as a line, tree, branch, or ring. Operating typically at 100 Mbit/s, EtherCAT ensures deterministic cycle times with low jitter. A key feature is its use of **Distributed Clocks**, which synchronize all nodes to a single, common time base, ensuring cohesive operation of devices across the network.

Data communication is managed through two distinct paths: a fast, cyclic path for process data and a separate mailbox channel for configuration data. To achieve hard real-time performance, the protocol avoids the overhead of IP/TCP/UDP for process data; instead, the frames are processed directly by the slave devices.

> This pattern is well suited for multi-axis motion control, as it allows the master to commit a schedule, ensuring all axes update in precise lock-step while sensors and encoders are sampled within the same cycle.

## How Aether Uses It

Aether treats microcontroller and I/O nodes like EtherCAT‑style devices: deterministic cycles, register‑mapped I/O, and descriptor‑driven discovery/configuration.

- Register‑mapped I/O mirrors fieldbus patterns, avoiding ad‑hoc command streams.
- Device descriptors allow discovery and robust configuration.
- Real‑time work stays in the “core”; higher‑level logic lives in the controller.
- Scales cleanly: one cable can service many axes, I/O blocks, and sensors with consistent timing.
- Unifies devices: supports mixed ecosystems (AetherMCU boards, third‑party EtherCAT drives/IO) on one bus.

- EtherCAT is considered a first‑class path for Aether’s real‑time network, but there is no hard lock‑in. Bridging modules can be used where needed rather than forcing everything through EtherCAT.
- Early milestones may ship with Aether’s own register‑based transport; full EtherCAT integration (and alternatives like LBP16) can land later without disrupting the architecture.

- Wiring/topology: line and ring are common; branches require appropriate couplers. Standard 100BASE‑TX cabling is typical.
- Power: “power over EtherCAT” exists in the ecosystem; suitability depends on device current and wiring—evaluate per design.

## Benefits of EtherCAT vs. Non‑Fieldbus Protocols (CAN, UART and USB)

Compared to CAN, UART, and USB, EtherCAT provides deterministic low‑jitter cycles and a global time base (Distributed Clocks). All nodes share one 100 Mbit/s frame that devices edit on‑the‑fly, so there are no per‑device handshakes or host‑side scheduling gaps. CAN/CAN‑FD have small payloads and arbitration jitter under load; UART is bandwidth‑limited and point‑to‑point; USB depends on the host scheduler and can introduce microframe jitter and queuing. For motion control, EtherCAT’s frame‑based, time‑synchronized model keeps axes and sensors in lock‑step.

- Lower jitter than USB/UART‑style links for time‑critical loops.
- One deterministic schedule rather than many unsynchronized device links.
- Clear separation of process data (fast) and configuration (mailbox) paths.

## FAQ

<Accordions>
  <Accordion title="Does Aether require EtherCAT?">
  No. EtherCAT is first‑class because it provides strong determinism and clean device integration, but Aether can run with an Aether‑native register bus and use bridges where appropriate. The architecture keeps the real‑time path “EtherCAT‑style” regardless, so adopting EtherCAT later is straightforward.
</Accordion>

<Accordions>
  <Accordion title="What devices go on EtherCAT?">
  Motor drives (steppers/servos), I/O modules (fans, heaters, end‑stops), encoders/sensors, and probe hardware like Beacon in 3D printing applications. Non‑real‑time peripherals remain on the controller side.
</Accordion>
