---
title: EtherCAT in Aether
description: Why Aether adopts an EtherCAT communication model for deterministic motion control.
icon: Network
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { Callout } from "fumadocs-ui/components/callout";

<Callout type="Info">
  ## Aether is still in development [!toc] [#alpha-warning]
  USB communication is planned to be used in early development until an EtherCAT protocol can be robustly implemented. 
</Callout>

## What Is EtherCAT? [#what-is-ethercat]

The [EtherCAT](https://en.wikipedia.org/wiki/EtherCAT) protocol is used in Aether because it is a real‑time [fieldbus](https://en.wikipedia.org/wiki/Fieldbus) that runs over standard Ethernet. A single master transmits a frame that passes through every device. Each device reads and writes its data on‑the‑fly at line rate. The frame then returns to the master carrying the updated process data for that cycle.

EtherCAT supports flexible topologies (line, tree/branch, ring) and typically runs at 100 Mbit/s with deterministic cycle times and low jitter. **Distributed Clocks (DCs)** synchronize all nodes to a single time base so devices act in lock‑step.

Two paths handle data:

- Fast cyclic process data (PDOs) for real‑time control.
- A separate mailbox channel (SDO/config) for setup and diagnostics.

This pattern is ideal for multi‑axis motion control: the master commits a schedule, all axes update together, and sensors/encoders are sampled inside the same cycle.

## How Aether Uses It [#how-ethercat-is-implemented]

Aether treats MCU and I/O nodes like EtherCAT‑style devices. Cycles are deterministic, I/O is register‑mapped, and devices describe themselves with descriptors for discovery, mapping, and safe defaults. This mirrors mature fieldbus practice and keeps the real‑time path clean and predictable: timing‑critical work runs inside the core while higher‑level logic lives on the controller. A single cable can service multiple axes, I/O blocks, and sensors with consistent timing, and both AetherMCU boards and third‑party EtherCAT devices can share the same bus.

### The Model

<Mermaid chart="
flowchart LR
  M[Master] -->|frame out| A[Node A]
  A -->|on-the-fly read/write| B[Node B]
  B -->|on-the-fly read/write| C[Node C]
  C -->|frame return| M
" />

### Interop and Migration

EtherCAT is first‑class, not a lock‑in. When we need to interoperate with other ecosystems (for example, Klipper‑style gear), we add a bridge inside the real‑time path rather than bending the core. Early milestones use an Aether‑native register transport that emulates a fieldbus; EtherCAT can land later without reshaping the architecture.

### Topology & Power

Aether systems can use standard 100BASE‑TX cabling and for networks requiring branching standard couplers can be used. “Power over EtherCAT” options exist in the industrial ecosystem and can be evaluated for use by the system designer.

### Timing Targets

Distributed Clocks provide deterministic cycles. On the host, real‑time scheduling helps meet tight time budgets.

## Benefits of EtherCAT vs. Non‑Fieldbus Protocols (CAN, UART and USB) [#ethercat-benefits-over-can-usb]

Under load, EtherCAT maintains deterministic timing because a single synchronized frame flows through every device. CAN arbitration, UART’s point‑to‑point bandwidth limits, and USB’s host‑scheduled microframes introduce jitter and queuing, which complicates precise motion control.

| Characteristic | EtherCAT | CAN / CAN‑FD | UART | USB |
| --- | --- | --- | --- | --- |
| Transport | Ethernet (100 Mbit/s typical) | Differential bus (1–8 Mbit/s) | Point‑to‑point (9600bps to 115200bps) | Host‑scheduled serial (12–480 Mbit/s) |
| Determinism under load | High (DCs + single shared frame) | Medium (arbitration jitter) | Low | Low–Medium (host microframes, queuing) |
| Global time base | Yes (Distributed Clocks) | No | No | No |
| Payload model | Process data (PDO) + mailbox (config) | Small frames | Bytes/lines | Packets via host controller |
| Topology | Line/branch/ring | Multi‑drop bus | 1:1 | Star (host‑centric) |

For printers and robotics, that determinism translates into crisp phase alignment across axes and predictable sampling windows for sensors and encoders. CAN and UART still fit slow or legacy peripherals where strict phase alignment is not required. USB remains convenient for early development and for host‑centric devices before EtherCAT hardware lands.

## FAQ

<Accordions>
  <Accordion title="Does Aether require EtherCAT?">
  No. EtherCAT is first‑class because it provides strong determinism and clean device integration, but Aether can run with an Aether‑native register bus and use bridges where appropriate. The Aether architecture keeps the real‑time path “EtherCAT‑style” regardless, so implementing EtherCAT later is straightforward.
  </Accordion>

  <Accordion title="What devices go on EtherCAT?">
  Motor drives (steppers/servos), I/O modules (fans, heaters, end‑stops), encoders/sensors, and toolhead probe hardware like Beacon in 3D printing applications. Non‑real‑time peripherals remain on the controller side.
  </Accordion>
</Accordions>
